[{"title":"Aptos & Move | 类型系统","url":"/2024/10/05/Aptos & Move  类型系统/","content":"\n## 0x00: 前言\n\nAptos move中的基础类型和其它语言大同小异，在学习aptos合约开发时，重点可以放在去清楚vector、table、sample map的可以进行的操作。本篇文章为参加Aptos共学的笔记，更加系统更加详细的内容可查看官方文档：https://aptos.dev/en/build/smart-contracts/book\n\n<br>\n\n## 0x01：integer\n\nMove仅支持6种无符号整数类型：`u8`、`u16`、`u32`、`u64`、`u128`、`u256`。\n\n在Move中，**数字常量值**可以添加**类型后缀**，如`22893u32`。此时，如果该值被用于赋值某变量，且该变量未指定类型，则编译会先尝试从常量值的上下文推断类型（根据变量名和常数值进行推断），再根据值的大小进行推断。\n\n除了**类型后缀**之外，数字常量值还可以用下划线`_`划分，如`1_234_5678`，`1_000u128`、`0xAB_CD_12_3`。使用该特点可以很方便地表示金额，如`10_000_000_000`。\n\n整数可以使用`+`、`-`、`*`、`/`、`%`进行运算，但均存在异常中断的可能。如`+`和`*`结果过大时，`-`结果小于0时，`/`和`%`除数为0时。另外，还可以进行`&`、`|`、`^`位运算，而位运算不会中止。\n\n在对整数进行一些运算操作时，会对整数的类型有要求。值得庆幸的是，整数类型可以进行转换：`(e as T)`，将e转为T类型，如果T类型装不下e，则会发生异常。在Move v2中，可以不用括号，`e as T`即可。\n\n<br>\n\n## 0x02: bool\n\n`bool`，值为`true`或`false`。可进行的逻辑运算：`&&`、`||`、`!`。\n\n<br>\n\n## 0x03: address\n\n`address`，是Move的内建类型。其256 bits。给定一个address，可以存储：**Modules**和**Resources**\n\n地址有两种类型: named 或 numerical。\n\n<br>\n\n## 0x04: signer\n\n`signer`是Move内置的资源类型。（？signer是一种允许**持有者**代表**特定地址**进行操作的能力）\n\n```rust\nmodule 0x1::signer {\n  struct signer has drop { addr: address }\n}\n```\n\n`signer`的值很特殊，不能通过数字值或指令来创建，只能由Move VM创建。\n\nsigner类型常见的一个操作函数是：`signer::address_of(&signer)`，返回值为内部包裹的address。\n\n<br>\n\n## 0x05: Vector\n\n有三种vector可以使用：\n\n- **vector**：基本的vector，和大多OOP语言中的一样。其内部是存储成byte array；\n\n- **big vector**：底层用table存储的vector，可以放大量数据；\n\n- **smart vector**：底层也是用table存储，放小量数据时和vector类似，放大量数据时和big vector类似，比较灵活；\n\n<br>\n\n#### 1. vector\n\n`vector<T>`：存储多个`T`类型的数值，可以扩大或收缩。\n\n> vector在Move中的一个常见用例是\"byte arrays\"，其本质为`vector<u8>`。比如，Byte String(`b\"Hello!\\n\"`)和Hex String(`x\"48656C6C6F210A\"`)。\n>\n\n常见操作：\n\n```rust\n// empty(),创建一个空的 vector。用于存储 u8 类型的数据\nlet mut v: vector<u8> = vector::empty<u8>();\n// 检查 vector 是否为空\nlet is_empty: bool = vector::is_empty(&v);\n\nvector::push_back(&mut v, 10);  // 向 vector 中添加值 10\nvector::push_back(&mut v, 20);  // 向 vector 中添加值 20\nlet len: u64 = vector::length(&v);  // 获取 vector 的长度\nlet removed_value: u8 = vector::pop_back(&mut v);  // 删除并返回最后一个元素\n\nlet val: &u8 = vector::borrow(&v, 0);  // 获取 vector 中第 0 个元素\nlet mut val: &mut u8 = vector::borrow_mut(&mut v, 0);  // 获取第 0 个元素的可变引用\n\nvector::swap(&mut v, 0, 50);  // 将 vector 中第 0 个元素替换为 50\n```\n\n还可以进行的操作有：附加另一个vector，vector内元素的倒置，判断是否包含某个元素，删除空的vector等等....\n\n<br>\n\n#### 2. big vector\n\n函数列表看起来怪怪的，还没使用过，后续看情况再补充这部分的内容吧。\n\n![image-20241005100952956](images/Aptos%20&%20Move%20%20%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F/image-20241005100952956.png)\n\n<br>\n\n#### 3. smart vector\n\n`smart vector`是基于`Table`的可扩展向量实现，其中元素被分组到存储桶(buckets)中。这种数据结构通过将小向量的灵活性与较大结构的可扩展性相结合，可以有效地处理大型数据集。\n\n常见操作:\n\n```rust\n// 创建空的smart vector\nnew<T: store>(): SmartVector<T>\n// 销毁空的vector\ndestroy_empty<T>(v: SmartVector<T>)\n// 销毁vector和内部的元素\ndestroy<T: drop>(v: SmartVector<T>)\n// 附加个元素\npush_back<T: store>(v: &mut SmartVector<T>, val: T)\n// 弹出末尾元素\npop_back<T>(v: &mut SmartVector<T>): T\n// 移除某个元素\nremove<T>(v: &mut SmartVector<T>, i: u64): T\n// 获取元素\nborrow<T>(v: &SmartVector<T>, i: u64): &T\n// 获取可变的元素\nborrow_mut<T>(v: &mut SmartVector<T>, i: u64): &mut T\n\nlength<T>(v: &SmartVector<T>): u64\nis_empty<T>(v: &SmartVector<T>): bool\nclear<T: drop>(v: &mut SmartVector<T>)\n// smart vector转为原生的vector\nto_vector<T: store + copy>(v: &SmartVector<T>): vector<T>\n```\n\n<br>\n\n## 0x06: Table\n\nTable分为两种，一个是基础的table，一个是smart table。\n\n<br>\n\n#### 1. table\n\n```rust\n// create Table\nnew<K: copy + drop, V: store>(): Table<K, V>\n\n// Aborts if the key already exists\nadd<K: copy + drop, V>(table: &mut Table<K, V>, key: K, val: V)\n// Aborts if the key is not found.\nremove<K: copy + drop, V>(table: &mut Table<K, V>, key: K): V\n// Inserts or updates a key-value pair.\nupsert<K: copy + drop, V: drop>(table: &mut Table<K, V>, key: K, value: V)\n\nborrow<K: copy + drop, V>(table: &Table<K, V>, key: K): &V\nborrow_with_default<K: copy + drop, V>(table: &Table<K, V>, key: K, default: &V): &V\nborrow_mut<K: copy + drop, V>(table: &mut Table<K, V>, key: K): &mut V\nborrow_mut_with_default<K: copy + drop, V: drop>(table: &mut Table<K, V>, key: K, default: V): &mut V\n\ncontains<K: copy + drop, V>(table: &Table<K, V>, key: K): bool\n```\n\n<br>\n\n#### 2. smart table\n\nsmart table是基于线性哈希（linear hash）的可扩展哈希表实现。旨在通过线性哈希来优化存储和性能。线性哈希一次分割一个存储桶，而不是将存储桶的数量加倍，从而避免意外的天然气成本。smart table使用 SipHash 函数来实现更快的哈希计算，同时容忍冲突。\n\n关键数据结构：\n\n```\nstruct SmartTable<K, V> has store {\n    buckets: table_with_length::TableWithLength<u64, vector<smart_table::Entry<K, V>>>,\n    num_buckets: u64,\n    level: u8,\n    size: u64,\n    split_load_threshold: u8,\n    target_bucket_size: u64\n}\n```\n\n操作：\n\n```\npublic fun new<K: copy, drop, store, V: store>(): smart_table::SmartTable<K, V>\npublic fun new_with_config()\npublic fun destroy_empty()\npublic fun destroy()\npublic fun clear()  // 清空\npublic fun add()   // 添加键值对\npublic fun add_all()\nremove()  // 通过键进行移除\nupsert()  // 插入或更新键值对\n\nborrow()\nborrow_with_default()\nborrow_mut()\nborrow_mut_with_default()\n\nlength()\nload_factor()  //返回load factor\nupdate_split_load_threshold()\nupdate_target_bucket_size()\nto_simple_map()\n```\n\n<br>\n\n## 0x07：Simple Map\n\n`aptos_std::simple_map`：（本质上是对vector的封装）\n\n```\n// 关键结构体\nstruct SimpleMap<Key, Value> has copy, drop, store\n\nlength()  // 获取长度\nnew()  //创建空的SimpleMap\nnew_from()  //使用vector类型的keys和values创建Simple\nborrow()\nborrow_mut()\ncontains_key()  // 是否含有某个key\ndestory_empty()\nadd()     //添加key/value，key不能已经存在\nadd_all()  // 联想new_from()\nupsert()   // 插入或更新\nkeys()    // 返回vector<key>\nvalues()   // 返回vector<value>\nto_vec_pair() // 返回(vector<Key>, vector<Value>)\ndestory()   // ???\nremove()   // key必须存在\nfind()     \n```\n\n<br>\n\n## 0x08: other\n\nMove中局部变量通过`let`进行定义，局部变量有一定的作用域。\n\n局部变量的名称可以包含`_`、`a-z` `A-Z`、`0-9`。但需要注意，开头必须为`_`或`a-z`开头，不允许以大写字母开头。\n\n在定义局部变量时可以添加类型注释：`let x: T = e`，或者由编译器进行推断。泛型可能推断不出来。\n\n一次定义多个局部变量：\n\n```\nlet (x, y): (&u64, &mut u64) = (&0, &mut 1);\n```\n\n","tags":["Aptos","Move"],"categories":["blockchain"]},{"title":"自动交易 | ccxt库的使用","url":"/2024/09/23/自动交易  ccxt库的使用/","content":"\n# 0x00：介绍\n\n**ccxt**，全称 CryptoCurrency eXchange Trading，是一个用于与加密货币交易所 API 进行交互的库。它支持多种交易所（如 Binance、Okx、Coinbase等），可以方便地获取市场数据、查询账户信息并执行交易等。ccxt库支持多种语言，如JavaScript、Python、PHP、C#，本文将使用Python进行演示。\n\n> 项目地址：https://github.com/ccxt/ccxt\n>\n> 使用文档：https://docs.ccxt.com/\n\n<br>\n\n# 0x01：安装\n\n确保安装了Python。\n\nccxt库的安装：\n\n```\npip install ccxt\n```\n\n<br>\n\n# 0x02：基础使用\n\n**public API**：可以实现大众的操作，不涉及到个人的。\n\n```python\nimport ccxt   # 导入ccxt库\nprint(ccxt.exchanges)  # 输出ccxt支持的所有交易所\n\nexchange = ccxt.binance()  # 创建Binance交易所实例\nmarkets = exchange.load_markets()  # 获取Binance所有交易对信息\nprint(markets)  # 打印交易对信息\n\nticker = exchange.fetch_ticker('BTC/USDT')  # 获取 BTC/USDT 的最新市场数据\nprint(ticker)  # 打印价格信息\n\n# timeframe: 时间帧，每根K线的时间长度； limit: K线条数\nK_data = exchange.fetch_ohlcv('BTC/USDT', '1h', 30)\nprint(k_data)\n```\n\n<br>\n\n**private API**：与个人账户相关联的操作。\n\n```python\n# 以API和私钥生成交易所实例\nexchange = ccxt.binance({\n    'apiKey': 'YOUR_API_KEY',\n    'secret': 'YOUR_SECRET_KEY',\n})\n\n# 获取账户余额\nbalance = exchange.fetch_balance()\nprint(balance)\n\n# 订单查询\norder_info = exchange.fetch_orders(symbol)     # 所有订单\norder_info = exchange.fetch_open_orders(symbol)  # 未完成的订单\norder_info = exchange.fetch_closed_orders(symbol)  # 已完成的订单\nprint(order_info)\n\n# 成交查询\nexchange.fetchMyTrades(symbol)\n\n# 限价交易，以60000美元价格买入0.001 BTC\norder = exchange.CreateLimitBuyOrder('BTC/USDT', 0.001, 20000)\nprint(order)\n\n# 市价交易，卖出0.001 BTC\norder = exchange.CreateMarketSellOrder('BTC/USDT', 0.001)\nprint(order)\n\n# 撤单\nexchange.CancelOrder(order_id)\n```\n\n<br>\n\n注意，在连接交易所时可能会网络问题，导致连接不上。这时可以尝试设置`proxies`字段指定走代理端口：\n\n```python\nexchange = ccxt.binance({\n    'apiKey': 'YOUR_API_KEY',\n    'secret': 'YOUR_SECRET_KEY',\n    'proxies': {\n        'http': 'http://127.0.0.1:10809',   # 我的代理端口为10809\n        'https': 'http://127.0.0.1:10809',\n    },\n})\n```\n\n<br>\n\n# 0x03：Demo\n\n实现一个涨买跌卖的简单策略。使用pandas库对ohlcv数据进行分析，得出交易信号，然后执行交易。\n\n```python\nimport ccxt\nimport time\nimport pandas\n\n# 初始化 Binance 交易所\nexchange = ccxt.binance({\n    'apiKey': '你的API_KEY',\n    'secret': '你的SECRET',\n})\n\n# 获取市场数据\ndef fetch_ohlcv(symbol, timeframe, limit=2):\n    ohlcv = exchange.fetch_ohlcv(symbol, timeframe, limit=limit)\n    df = pandas.DataFrame(ohlcv, columns=['timestamp', 'open', 'high', 'low', 'close', 'volume'])\n    df['timestamp'] = pandas.to_datetime(df['timestamp'], unit='ms')\n    # df.set_index('timestamp', inplace=True)  # 将 timestamp 列设为索引\n    return df\n\n# 简单交易策略\ndef strategy(df):\n    if df.iloc[-1]['close'] > df.iloc[-2]['close']:\n        return 'buy'\n    elif df.iloc[-1]['close'] < df.iloc[-2]['close']:\n        return 'sell'\n    else:\n        return 'hold'\n\n# 执行策略\nsymbol = 'BTC/USDT'\ntimeframe = '1m'  # 1分钟K线\n\nwhile True:\n    try:\n        # 获取最近的两条K线数据\n        df = fetch_ohlcv(symbol, timeframe)\n\n        # 执行策略\n        action = strategy(df)\n\n        if action == 'buy':\n            # 模拟买入0.001 BTC\n            order = exchange.create_order(symbol, 'market', 'buy', 0.001)\n            print(f'买入订单：{order}')\n\n        elif action == 'sell':\n            # 模拟卖出0.001 BTC\n            order = exchange.create_order(symbol, 'market', 'sell', 0.001)\n            print(f'卖出订单：{order}')\n        \n        # 每分钟检查一次\n        time.sleep(60)\n\n    except Exception as e:\n        print(f\"出错: {e}\")\n```\n\n<br>\n\n# 0x04：总结\n\n这篇文章对ccxt的简单使用进行了介绍，对于更多的详细内容，可查阅[官方文档](https://docs.ccxt.com/)。","tags":["交易","自动化"],"categories":["blockchain"]},{"title":"ERC20标准介绍及代币实现","url":"/2024/09/19/ERC20标准介绍及代币实现/","content":"\n# 0x00：ERC20标准\n\nERC20标准是由EIP-20定义，规定了代币的功能和接口，以确保兼容性和互操作性。\n\n在[ERC20标准](https://github.com/ethereum/ercs/blob/master/ERCS/erc-20.md)中，定义了2个事件和6个函数，以及3个可选的函数：\n\n- **Transfer事件**：必须在代币转移时触发，包括零值转移。代币合约在生成新的代币时（比如mint），也应该触发转移事件，其将`_from`地址设置为0x0。\n\n  `event Transfer(address indexed _from, address indexed _to, uint256 _value);`\n\n- **Approval事件**：必须在任何成功调用`approve(address _spender, uint256 _value)`时触发。`event Approval(address indexed _owner, address indexed _spender, uint256 _value);`\n\n<br>\n\n- **totalSupply()函数**：返回代币的当前供应量；\n\n  `function totalSupply() public view returns (uint256);`\n\n- **balanceOf()函数**：返回账户的代币余额。\n\n  `function balanceOf(address _owner) public view returns (uint256 balance);`\n\n- **transfer()函数**：将调用者数量为`_value`的代币转移到地址`_to`上，并且必须触发`Transfer`事件。如果消息调用者的账户余额没有足够的代币可供使用，则该函数应该抛出异常。\n\n  `function transfer(address _to, uint256 _value) public returns (bool success);`\n\n- **transferFrom()函数**：将数量为`_value`的代币从地址`_from`转移到地址`_to`，并且必须触发`Transfer`事件。该`transferFrom`方法用于提款工作流，允许合约代表您转移代币。例如，这可用于允许合约代表您转移代币和/或以子货币收取费用。函数应该抛出异常，除非`_from`帐户已通过某种机制有意授权消息发送者。\n\n  `function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);`\n\n- **approve()函数**：允许`_spender`多次从消息调用者的帐户提款，最高金额为`_value`。如果再次调用此函数，它将用`_value`覆盖当前限额。\n\n  `function approve(address _spender, uint256 _value) public returns (bool success);`\n\n- **allowance()函数**：返回`_spender`仍允许`_owner`提取的金额。\n\n  `function allowance(address _owner, address _spender) public view returns (uint256 remaining);`\n\n\n\n可选的：\n\n- **name()函数**：返回代币的名字；\n\n  `function name() public view returns (string);`\n\n- **symbol()函数**：返回代币的符号；\n\n  `function symbol() public view returns (string);`\n\n- **decimals()函数**：返回代币使用的精度；\n\n  `function decimals() public view returns (uint8);`\n\n<br>\n\n# 0x01：ERC20代币实现\n\nERC20标准规定的接口定义了代币的操作，至于代币如何产生，由我们自己决定。这里以实现一个Wrapped ETH为练习，Wrapped ETH是以太币ETH的ERC20包装版本。由于以太币本身并不符合 ERC20 标准，导致与其他代币之间的互操作性较弱，难以用于去中心化应用程序中。WETH可以1:1与ETH互相兑换。\n\n因此，除了实现ERC20接口的函数外，还需要定义两个函数：\n\n- deposit：存款，将ETH转为我们的代币；\n- withdraw：取款，将我们的代币转为ETH；\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// ERC20 接口规范\ninterface IERC20 {\n\tevent Transfer(address indexed _from, address indexed _to, uint256 _value);\n\tevent Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\t\n\tfunction totalSupply() external view returns (uint256);\n\tfunction balanceOf(address _owner) external view returns (uint256 balance);\n\tfunction transfer(address _to, uint256 _value) external returns (bool success);\n\tfunction transferFrom(address _from, address _to, uint256 _value) external returns (boolsuccess);\n\tfunction approve(address _spender, uint256 _value) external returns (bool success);\n\tfunction allowance(address _owner, address _spender) external view returns (uint256 remaining);\n}\n\ncontract WETH is IERC20 {\n    string public _name = \"Wrapped Ether\";\n\tstring public _symbol = \"WETH\";\n\tuint8  public _decimals = 18;\n\t\n\tmapping (address => uint) public _balances;\n\tmapping (address => mapping (address => uint)) public _allowance;\n\t\n\tevent Deposit(address _user, uint256 _value);\n\tevent Withdrawal(address _user, uint256 _value);\n\n    // 存款, ETH -> WETH\n    function deposit() public payable {\n\t\t_balances[msg.sender] += msg.value;\n\t\temit Deposit(msg.sender, msg.value);\n\t}\n\n    // 提款, WETH -> ETH\n    function withdraw(uint256 amount) public {\n        require((_balances[msg.sender] - amount) > 0,\"Not enough balance.\");\n        _balances[msg.sender] -= amount;\n        (bool success, ) = msg.sender.call{value: amount}(\"\");\n        require(success,\"Withdrawal failed\");\n        emit Withdrawal(msg.sender, amount);\n    }\n\n    // IERC20 totalSupply\n    function totalSupply() external view override returns (uint256) {\n        return address(this).balance;\n    }\n\n    // IERC20 balanceOf\n    function balanceOf(address _owner) external view override returns (uint256 balance) {\n        balance = _balances[_owner];\n    }\n    \n    // IERC20 transfer\n    function transfer(address _to, uint256 _value) external override returns (bool success) {\n        require(_balances[msg.sender] > _value,\"Not enough balance.\");\n        _balances[msg.sender] -= _value;\n        _balances[_to] += _value;\n        emit Transfer(msg.sender, _to, _value);\n        success = true ;\n     }\n\n    // IERC20 transferFrom\n    function transferFrom(address _from, address _to, uint256 _value) external override returns (bool success) {\n        require(_balances[_from] >=_value,\"Not enough balance.\");\n        require((_allowance[_from][msg.sender] -_value) >0,\"Not enough balance.\");\n        \n        _allowance[_from][msg.sender] -=_value;\n        _balances[_from] -=_value;\n        _balances[_to] +=_value;\n        emit Transfer(_from,_to,_value);\n        success = true;\n    }\n\n     // IERC20 approve\n    function approve(address _spender, uint256 _value) external override returns (bool success) {\n         _allowance[msg.sender][_spender] = _value;\n         emit Approval(msg.sender, _spender, _value);\n         success = true ;\n    }\n\n    // IERC20 allowance\n    function allowance(address _owner, address _spender) external view override returns (uint256 remaining) {\n        remaining = _allowance[_owner][_spender];\n    }\n}\n```\n\n<br>\n\n# 0x02：另外\n\nERC20接口的实现部分其实大差不差，因此可以通过继承使用他人的实现。openZeppelin是被大家所认可的库，其中也有[ERC20标准的实现](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol)。\n\n通过openZeppelin库，要想创建一个ERC20代币，仅需：\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ncontract MyToken is ERC20 {\n    constructor(uint256 initialSupply) ERC20(\"MyToken\", \"MTK\") {\n    }\n}\n```\n\n这是因为在导入的ERC20.sol实现了接口：\n\n```solidity\n// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"./IERC20.sol\";\nimport {IERC20Metadata} from \"./extensions/IERC20Metadata.sol\";\nimport {Context} from \"../../utils/Context.sol\";\nimport {IERC20Errors} from \"../../interfaces/draft-IERC6093.sol\";\n\nabstract contract ERC20 is Context, IERC20, IERC20Metadata, IERC20Errors {\n    mapping(address account => uint256) private _balances;\n\n    mapping(address account => mapping(address spender => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n    .......\n    function transfer(address to, uint256 value) public virtual returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, value);\n        return true;\n    }\n\n    function allowance(address owner, address spender) public view virtual returns (uint256) {\n        return _allowances[owner][spender];\n    }\n    ......\n}\n```\n\n同时该ERC20.sol为抽象合约，我们可以继承它。","tags":["以太坊","solidity"],"categories":["blockchain"]},{"title":"Telegram Bot开发01：创建自己的Bot","url":"/2024/09/06/Telegram-Bot开发01：创建自己的Bot/","content":"\n# 0x00: 介绍\n\nTelegram Bot 是在 Telegram上运行的自动化账户，用户可以和它聊天，或者在群组和频道中使用它们。通过对Telegram Bot进行开发，可以实现如聊天机器人、自动化工具、游戏等等功能。\n\nBotFather是一个专门用来管理其他Bot的Telegram账户。通过BotFather，可以创建一个新的Bot，并且对Bot设置名称、描述、命令列表等等。\n\n本篇文章将会介绍如何创建一个Bot，并对Bot进行基本设置。与此同时，还会讲解相关的概念。\n\n\n\n# 0x01：创建Bot\n\n打开[@BotFather](https://t.me/botfather)：\n\n![image-20240820094023202](/images/Telegram-Bot%E5%BC%80%E5%8F%9101%EF%BC%9A%E5%88%9B%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84Bot/image-20240820094023202.png)\n\n\n\n创建机器人：发送`/newbot`指令创建机器人，随后设置Bot的名称和用户名。\n\n![image-20240820094343570](/images/Telegram-Bot%E5%BC%80%E5%8F%9101%EF%BC%9A%E5%88%9B%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84Bot/image-20240820094343570.png)\n\n在成功创建Bot后，会给你一个API Token，这是与你机器人进行HTTP请求交互的关键。请务必保存好，不要泄漏。\n\n通过浏览器访问：`https://api.telegram.org/bot<API Token>/getMe` (API Token替换成你的)\n\n会返回JSON格式的Bot相关信息：\n\n```json\n{\n  \"ok\": true,\n  \"result\": {\n    \"id\": 7190564445,\n    \"is_bot\": true,\n    \"first_name\": \"BotDemo\",\n    \"username\": \"demo18293_bot\",\n    \"can_join_groups\": true,\n    \"can_read_all_group_messages\": false,\n    \"supports_inline_queries\": true,\n    \"can_connect_to_business\": false,\n    \"has_main_web_app\": false\n  }\n}\n```\n\n\n\n# 0x02：相关概念\n\n这里先介绍一下Bot相关的概念，方便后面的编辑操作。\n\n### 1. 命令列表\n\n当你在Bot的对话框中输入`/`（点击菜单同理），就会列出所有命令：\n\n![image-20240821144721503](../images/Telegram-Bot%E5%BC%80%E5%8F%9101%EF%BC%9A%E5%88%9B%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84Bot/image-20240821144721503.png)\n\n前方的粗体是具体命令，后方的灰字是对命令的说明。\n\n\n\n### 2. 内联模式\n\n内联模式（inline mode）允许用户在任何聊天窗口（包括与其他用户的对话或群组中）通过输入Bot的**用户名**来触发内联查询：\n\n![image-20240821145635903](./images/Telegram-Bot%E5%BC%80%E5%8F%9101%EF%BC%9A%E5%88%9B%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84Bot/image-20240821145635903.png)\n\nBot会返回结果供用户选择，并发送到当前聊天中。\n\n\n\n### 3. 回复键盘\n\n回复键盘（Reply Keyboard）是一种出现在输入框下方的按钮集合。点击按钮，会发送预设好的消息：\n\n![image-20240821150329284](./images/Telegram-Bot%E5%BC%80%E5%8F%9101%EF%BC%9A%E5%88%9B%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84Bot/image-20240821150329284.png)\n\n你点击【❓ 帮助】按钮，和直接发送”❓ 帮助“消息是一样的。\n\n\n\n### 4. 内联键盘\n\n内联键盘（Inline Keyboard）是一种在消息内容下方显示的按钮。与”回复键盘“不同，点击按钮时，并不会发送消息，而是进行相关操作，比如说：执行特定的命令、打开网址、发起支付等等。\n\n![image-20240821151648011](./images/Telegram-Bot%E5%BC%80%E5%8F%9101%EF%BC%9A%E5%88%9B%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84Bot/image-20240821151648011.png)\n\n\n\n# 0x03：编辑Bot\n\n编辑Bot有两种方式，一种是直接发送`/setxxx`命令，另外一种比较方便，通过内联键盘进行设置。虽然方式不同，但本质是一样的，每个键盘选项大都对应着相关的命令。这里就以后者进行演示：\n\n发送`/mybots`命令，然后选择Bot：\n\n![image-20240821135829637](./images/Telegram-Bot%E5%BC%80%E5%8F%9101%EF%BC%9A%E5%88%9B%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84Bot/image-20240821135829637.png)\n\n点击【Edit Bot】：\n\n![image-20240821140029492](./images/Telegram-Bot%E5%BC%80%E5%8F%9101%EF%BC%9A%E5%88%9B%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84Bot/image-20240821140029492.png)\n\n上面的消息是Bot当前的设置，下面是可进行的操作。每个选项大都有着对应的命令：\n\n- 【Edit Name】<==> `/setname `：设置Bot的名称；\n- 【Edit About】<==> `/setabouttext`：设置Bot的关于信息，在Bot的个人资料页面上可以看到；\n- 【Edit Description】<==> `/setdescription`：设置Bot的描述，将在与Bot对话的开头看到；\n- 【Edit Description Picture】：(没有命令) 设置描述上方的图片，可以是GIF，不过对尺寸有要求；\n- 【Edit Botpic】<==> `/setuserpic`：设置Bot的头像；\n- 【Edit Commands】<==> `/setcommands`：设置Bot支持的命令列表；（命令 + 说明）\n- 【Edit inline placeholder】<==> `/setinline`：设置Bot内联查询的提示词；\n- 【Edit Privacy Policy】：设置隐私条款，未设置时默认为使用官方的隐私条款；\n\n以上就是Bot的基本设置！\n\n\n\n另外，列一些个人觉得比较重要的命令：\n\n```\n/token:  获取HTTP API token\n/revoke: 吊销HTTP API token\n/cancel: 取消当前正在进行的操作\n/deletebot: 删除机器人\n```\n\n\n\n# 0x04：最后\n\n本篇文章的操作捏出了Bot的**形**，但是还不能进行真正的处理。虽然定义了命令列表，但此时发送命令，Bot是没有任何反应的。后面我们还需要给Bot编写程序，注入灵魂，让它动起来。\n\n\n\n","tags":["TON"],"categories":["blockchain"]},{"title":"广州到深圳之莽夫骑行","url":"/2024/08/06/hello-world/","content":"\n\n# 待更新...\n","tags":["骑行"],"categories":["life"]},{"title":"Android逆向：修改APK并重打包签名","url":"/2024/08/06/修改APK并重打包签名/","content":"\n在Android逆向中，经常需要对APK修改，然后重新打包并签名。这篇文章中，介绍了如何使用各个工具来完成这个过程。\n\n各个步骤以及所需工具：\n\n1. 解压APK文件； 工具：apktool\n2. 进行修改； 工具：看修改需求\n3. 重新打包APK； 工具：apktool\n4. 将APK对齐； 工具：zipalign\n5. 生成密钥文件，并对APK进行签名；工具：keytool、jarsigner\n\n\n\n小白鼠：demo.apk\n\n#### 目标：\n\n将`addThreeNum(1, 2, 3)`改为`addThreeNum(4, 5, 6)`，并且修改后能够成功运行。\n\n![image-20240806103111215](/images/修改APK并重打包签名/image-20240806103111215.png)\n\n\n\n> demo.apk下载：https://www.123pan.com/s/9j4Xjv-MMAhv.html?提取码:tgno\n>\n> 用到的工具可自行从网上获取。\n\n\n\n#### 步骤1：解压APK\n\n使用apktool解压APK到output目录下\n\n```powershell\nE:\\> apktool d .\\demo.apk -o output\\\nI: Using Apktool 2.7.0 on demo.apk\nI: Loading resource table...\nI: Decoding AndroidManifest.xml with resources...\nI: Loading resource table from file: C:\\Users\\aaaka\\AppData\\Local\\apktool\\framework\\1.apk\nI: Regular manifest package...\nI: Decoding file-resources...\nI: Decoding values */* XMLs...\nI: Baksmaling classes.dex...\nI: Copying assets and libs...\nI: Copying unknown files...\nI: Copying original files...\nI: Copying META-INF/services directory\n```\n\n\n\n#### 步骤2：修改\n\n在output\\smali\\com\\example\\myapplication\\MainActivity.smail中，把`1 2 3 `改为` 4 5 6`\n\n![image-20240806095045017](/images/修改APK并重打包签名/image-20240806095045017.png)\n\n\n\n#### 步骤3：重打包\n\n解压的逆过程，将output目录打包为newdemo.apk\n\n```powershell\nE:\\> apktool b output\\ -o .\\newdemo.apk\nI: Using Apktool 2.7.0\nI: Checking whether sources has changed...\nI: Smaling smali folder into classes.dex...\nI: Checking whether resources has changed...\nI: Building resources...\nI: Copying libs... (/lib)\nI: Copying libs... (/kotlin)\nI: Copying libs... (/META-INF/services)\nI: Building apk file...\nI: Copying unknown files/dir...\nI: Built apk into: .\\newdemo.apk\n```\n\n\n\n#### 步骤4：APK对齐\n\n（注意：当用到NDK开发，含有.so库时，需要添加`-p`参数）\n\n```powershell\nE:\\> zipalign -p -v 4 .\\newdemo.apk .\\newdemo-aligned.apk\nVerifying alignment of .\\newdemo-aligned.apk (4)...\n      49 AndroidManifest.xml (OK - compressed)\n    1688 classes.dex (OK - compressed)\n 3296246 kotlin/annotation/annotation.kotlin_builtins (OK - compressed)\n 3296897 kotlin/collections/collections.kotlin_builtins (OK - compressed)\n 3298508 kotlin/coroutines/coroutines.kotlin_builtins (OK - compressed)\n \t\t\t\t......(省略)......\n 3731560 resources.arsc (OK)\n 4709532 assets/dexopt/baseline.prof (OK)\n 4711368 assets/dexopt/baseline.profm (OK)\n 4711611 DebugProbesKt.bin (OK - compressed)\nVerification succesful\n```\n\n\n\n#### 步骤5：生成`.jks`密钥文件\n\n各个参数的含义可自行了解\n\n```powershell\nE:\\> keytool -genkeypair -v -keystore key.jks -keyalg RSA -keysize 2048 -validity 10000 -alias akakey\n输入密钥库口令:\n再次输入新口令:\n您的名字与姓氏是什么?\n  [Unknown]:  aka\n您的组织单位名称是什么?\n  [Unknown]:  Reverse\n您的组织名称是什么?\n  [Unknown]:  Android\n您所在的城市或区域名称是什么?\n  [Unknown]:  shenzhen\n您所在的省/市/自治区名称是什么?\n  [Unknown]:  guangdong\n该单位的双字母国家/地区代码是什么?\n  [Unknown]:  CN\nCN=aka, OU=Reverse, O=Android, L=shenzhen, ST=guangdong, C=CN是否正确?\n  [否]:  是\n\n正在为以下对象生成 2,048 位RSA密钥对和自签名证书 (SHA256withRSA) (有效期为 10,000 天):\n         CN=aka, OU=Reverse, O=Android, L=shenzhen, ST=guangdong, C=CN\n[正在存储key.jks]\n```\n\n\n\n#### 步骤6：重签名\n\n```powershell\nE:\\> apksigner sign --ks key.jks --ks-key-alias akakey --out .\\newdemo-aligned-signed.apk .\\newdemo-aligned.apk\nKeystore password for signer #1:\nE:\\>\n```\n\n\n\n#### 最后：尝试运行\n\n可以成功运行，并且修改有效。\n\n![image-20240806102009372](/images/修改APK并重打包签名/image-20240806102009372.png)\n\n\n\n#### 思考：\n\n既然APK可以二次签名，并且能够成功运行。那么，APK中签名机制所起到的作用是什么呢？就是资源文件中META-INF目录下的`.RSA .SF .MF`三个文件。\n\n![image-20240806120006871](/images/修改APK并重打包签名/image-20240806120006871.png)","tags":["Android","逆向"],"categories":["security"]}]