[{"title":"ERC20标准介绍及代币实现","url":"/2024/09/19/ERC20标准介绍及代币实现/","content":"\n# 0x00：ERC20标准\n\nERC20标准是由EIP-20定义，规定了代币的功能和接口，以确保兼容性和互操作性。\n\n在[ERC20标准](https://github.com/ethereum/ercs/blob/master/ERCS/erc-20.md)中，定义了2个事件和6个函数，以及3个可选的函数：\n\n- **Transfer事件**：必须在代币转移时触发，包括零值转移。代币合约在生成新的代币时（比如mint），也应该触发转移事件，其将`_from`地址设置为0x0。\n\n```\nevent Transfer(address indexed _from, address indexed _to, uint256 _value);\n```\n\n- **Approval事件**：必须在任何成功调用`approve(address _spender, uint256 _value)`时触发。\n\n```\nevent Approval(address indexed _owner, address indexed _spender, uint256 _value);\n```\n\n\n\n- **totalSupply**：返回代币的当前供应量；\n\n```\nfunction totalSupply() public view returns (uint256);\n```\n\n- **balanceOf**：返回账户的代币余额；\n\n```\nfunction balanceOf(address _owner) public view returns (uint256 balance);\n```\n\n- **transfer**：将调用者数量为`_value`的代币转移到地址`_to`上，并且必须触发`Transfer`事件。如果消息调用者的账户余额没有足够的代币可供使用，则该函数应该抛出异常。\n\n```\nfunction transfer(address _to, uint256 _value) public returns (bool success);\n```\n\n- **transferFrom**：将数量为`_value`的代币从地址`_from`转移到地址`_to`，并且必须触发`Transfer`事件。该`transferFrom`方法用于提款工作流，允许合约代表您转移代币。例如，这可用于允许合约代表您转移代币和/或以子货币收取费用。函数应该抛出异常，除非`_from`帐户已通过某种机制有意授权消息发送者。\n\n```\nfunction transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n```\n\n- **approve**：允许`_spender`多次从消息调用者的帐户提款，最高金额为`_value`。如果再次调用此函数，它将用`_value`覆盖当前限额。\n\n```\nfunction approve(address _spender, uint256 _value) public returns (bool success);\n```\n\n- **allowance**：返回`_spender`仍允许`_owner`提取的金额。\n\n```\nfunction allowance(address _owner, address _spender) public view returns (uint256 remaining);\n```\n\n\n\n可选的：\n\n- **name**：返回代币的名字；\n\n```\nfunction name() public view returns (string);\n```\n\n- **symbol**：返回代币的符号；\n\n```\nfunction symbol() public view returns (string);\n```\n\n- **decimals**：返回代币使用的精度；\n\n```\nfunction decimals() public view returns (uint8);\n```\n\n\n\n# 0x01：ERC20代币实现\n\nERC20标准规定的接口定义了代币的操作，至于代币如何产生，由我们自己决定。这里以实现一个Wrapped ETH为练习，Wrapped ETH是以太币ETH的ERC20包装版本。由于以太币本身并不符合 ERC20 标准，导致与其他代币之间的互操作性较弱，难以用于去中心化应用程序中。WETH可以1:1与ETH互相兑换。\n\n因此，除了实现ERC20接口的函数外，还需要定义两个函数：\n\n- deposit：存款，将ETH转为我们的代币；\n- withdraw：取款，将我们的代币转为ETH；\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// ERC20 接口规范\ninterface IERC20 {\n\tevent Transfer(address indexed _from, address indexed _to, uint256 _value);\n\tevent Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\t\n\tfunction totalSupply() external view returns (uint256);\n\tfunction balanceOf(address _owner) external view returns (uint256 balance);\n\tfunction transfer(address _to, uint256 _value) external returns (bool success);\n\tfunction transferFrom(address _from, address _to, uint256 _value) external returns (boolsuccess);\n\tfunction approve(address _spender, uint256 _value) external returns (bool success);\n\tfunction allowance(address _owner, address _spender) external view returns (uint256 remaining);\n}\n\ncontract WETH is IERC20 {\n    string public _name = \"Wrapped Ether\";\n\tstring public _symbol = \"WETH\";\n\tuint8  public _decimals = 18;\n\t\n\tmapping (address => uint) public _balances;\n\tmapping (address => mapping (address => uint)) public _allowance;\n\t\n\tevent Deposit(address _user, uint256 _value);\n\tevent Withdrawal(address _user, uint256 _value);\n\n    // 存款, ETH -> WETH\n    function deposit() public payable {\n\t\t_balances[msg.sender] += msg.value;\n\t\temit Deposit(msg.sender, msg.value);\n\t}\n\n    // 提款, WETH -> ETH\n    function withdraw(uint256 amount) public {\n        require((_balances[msg.sender] - amount) > 0,\"Not enough balance.\");\n        _balances[msg.sender] -= amount;\n        (bool success, ) = msg.sender.call{value: amount}(\"\");\n        require(success,\"Withdrawal failed\");\n        emit Withdrawal(msg.sender, amount);\n    }\n\n    // IERC20 totalSupply\n    function totalSupply() external view override returns (uint256) {\n        return address(this).balance;\n    }\n\n    // IERC20 balanceOf\n    function balanceOf(address _owner) external view override returns (uint256 balance) {\n        balance = _balances[_owner];\n    }\n    \n    // IERC20 transfer\n    function transfer(address _to, uint256 _value) external override returns (bool success) {\n        require(_balances[msg.sender] > _value,\"Not enough balance.\");\n        _balances[msg.sender] -= _value;\n        _balances[_to] += _value;\n        emit Transfer(msg.sender, _to, _value);\n        success = true ;\n     }\n\n    // IERC20 transferFrom\n    function transferFrom(address _from, address _to, uint256 _value) external override returns (bool success) {\n        require(_balances[_from] >=_value,\"Not enough balance.\");\n        require((_allowance[_from][msg.sender] -_value) >0,\"Not enough balance.\");\n        \n        _allowance[_from][msg.sender] -=_value;\n        _balances[_from] -=_value;\n        _balances[_to] +=_value;\n        emit Transfer(_from,_to,_value);\n        success = true;\n    }\n\n     // IERC20 approve\n    function approve(address _spender, uint256 _value) external override returns (bool success) {\n         _allowance[msg.sender][_spender] = _value;\n         emit Approval(msg.sender, _spender, _value);\n         success = true ;\n    }\n\n    // IERC20 allowance\n    function allowance(address _owner, address _spender) external view override returns (uint256 remaining) {\n        remaining = _allowance[_owner][_spender];\n    }\n}\n```\n\n\n\n# 0x02：另外\n\nERC20接口的实现部分其实大差不差，因此可以通过继承使用他人的实现。openZeppelin是被大家所认可的库，其中也有[ERC20标准的实现](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol)。\n\n通过openZeppelin库，要想创建一个ERC20代币，仅需：\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ncontract MyToken is ERC20 {\n    constructor(uint256 initialSupply) ERC20(\"MyToken\", \"MTK\") {\n    }\n}\n```\n\n这是因为在导入的ERC20.sol实现了接口：\n\n```solidity\n// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"./IERC20.sol\";\nimport {IERC20Metadata} from \"./extensions/IERC20Metadata.sol\";\nimport {Context} from \"../../utils/Context.sol\";\nimport {IERC20Errors} from \"../../interfaces/draft-IERC6093.sol\";\n\nabstract contract ERC20 is Context, IERC20, IERC20Metadata, IERC20Errors {\n    mapping(address account => uint256) private _balances;\n\n    mapping(address account => mapping(address spender => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n    .......\n    function transfer(address to, uint256 value) public virtual returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, value);\n        return true;\n    }\n\n    function allowance(address owner, address spender) public view virtual returns (uint256) {\n        return _allowances[owner][spender];\n    }\n    ......\n}\n```\n\n同时该ERC20.sol为抽象合约，我们可以继承它。","tags":["以太坊","solidity"],"categories":["blockchain"]},{"title":"Telegram Bot开发01：创建自己的Bot","url":"/2024/09/06/Telegram-Bot开发01：创建自己的Bot/","content":"\n# 0x00: 介绍\n\nTelegram Bot 是在 Telegram上运行的自动化账户，用户可以和它聊天，或者在群组和频道中使用它们。通过对Telegram Bot进行开发，可以实现如聊天机器人、自动化工具、游戏等等功能。\n\nBotFather是一个专门用来管理其他Bot的Telegram账户。通过BotFather，可以创建一个新的Bot，并且对Bot设置名称、描述、命令列表等等。\n\n本篇文章将会介绍如何创建一个Bot，并对Bot进行基本设置。与此同时，还会讲解相关的概念。\n\n\n\n# 0x01：创建Bot\n\n打开[@BotFather](https://t.me/botfather)：\n\n![image-20240820094023202](/images/Telegram-Bot%E5%BC%80%E5%8F%9101%EF%BC%9A%E5%88%9B%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84Bot/image-20240820094023202.png)\n\n\n\n创建机器人：发送`/newbot`指令创建机器人，随后设置Bot的名称和用户名。\n\n![image-20240820094343570](/images/Telegram-Bot%E5%BC%80%E5%8F%9101%EF%BC%9A%E5%88%9B%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84Bot/image-20240820094343570.png)\n\n在成功创建Bot后，会给你一个API Token，这是与你机器人进行HTTP请求交互的关键。请务必保存好，不要泄漏。\n\n通过浏览器访问：`https://api.telegram.org/bot<API Token>/getMe` (API Token替换成你的)\n\n会返回JSON格式的Bot相关信息：\n\n```json\n{\n  \"ok\": true,\n  \"result\": {\n    \"id\": 7190564445,\n    \"is_bot\": true,\n    \"first_name\": \"BotDemo\",\n    \"username\": \"demo18293_bot\",\n    \"can_join_groups\": true,\n    \"can_read_all_group_messages\": false,\n    \"supports_inline_queries\": true,\n    \"can_connect_to_business\": false,\n    \"has_main_web_app\": false\n  }\n}\n```\n\n\n\n# 0x02：相关概念\n\n这里先介绍一下Bot相关的概念，方便后面的编辑操作。\n\n### 1. 命令列表\n\n当你在Bot的对话框中输入`/`（点击菜单同理），就会列出所有命令：\n\n![image-20240821144721503](../images/Telegram-Bot%E5%BC%80%E5%8F%9101%EF%BC%9A%E5%88%9B%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84Bot/image-20240821144721503.png)\n\n前方的粗体是具体命令，后方的灰字是对命令的说明。\n\n\n\n### 2. 内联模式\n\n内联模式（inline mode）允许用户在任何聊天窗口（包括与其他用户的对话或群组中）通过输入Bot的**用户名**来触发内联查询：\n\n![image-20240821145635903](./images/Telegram-Bot%E5%BC%80%E5%8F%9101%EF%BC%9A%E5%88%9B%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84Bot/image-20240821145635903.png)\n\nBot会返回结果供用户选择，并发送到当前聊天中。\n\n\n\n### 3. 回复键盘\n\n回复键盘（Reply Keyboard）是一种出现在输入框下方的按钮集合。点击按钮，会发送预设好的消息：\n\n![image-20240821150329284](./images/Telegram-Bot%E5%BC%80%E5%8F%9101%EF%BC%9A%E5%88%9B%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84Bot/image-20240821150329284.png)\n\n你点击【❓ 帮助】按钮，和直接发送”❓ 帮助“消息是一样的。\n\n\n\n### 4. 内联键盘\n\n内联键盘（Inline Keyboard）是一种在消息内容下方显示的按钮。与”回复键盘“不同，点击按钮时，并不会发送消息，而是进行相关操作，比如说：执行特定的命令、打开网址、发起支付等等。\n\n![image-20240821151648011](./images/Telegram-Bot%E5%BC%80%E5%8F%9101%EF%BC%9A%E5%88%9B%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84Bot/image-20240821151648011.png)\n\n\n\n# 0x03：编辑Bot\n\n编辑Bot有两种方式，一种是直接发送`/setxxx`命令，另外一种比较方便，通过内联键盘进行设置。虽然方式不同，但本质是一样的，每个键盘选项大都对应着相关的命令。这里就以后者进行演示：\n\n发送`/mybots`命令，然后选择Bot：\n\n![image-20240821135829637](./images/Telegram-Bot%E5%BC%80%E5%8F%9101%EF%BC%9A%E5%88%9B%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84Bot/image-20240821135829637.png)\n\n点击【Edit Bot】：\n\n![image-20240821140029492](./images/Telegram-Bot%E5%BC%80%E5%8F%9101%EF%BC%9A%E5%88%9B%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84Bot/image-20240821140029492.png)\n\n上面的消息是Bot当前的设置，下面是可进行的操作。每个选项大都有着对应的命令：\n\n- 【Edit Name】<==> `/setname `：设置Bot的名称；\n- 【Edit About】<==> `/setabouttext`：设置Bot的关于信息，在Bot的个人资料页面上可以看到；\n- 【Edit Description】<==> `/setdescription`：设置Bot的描述，将在与Bot对话的开头看到；\n- 【Edit Description Picture】：(没有命令) 设置描述上方的图片，可以是GIF，不过对尺寸有要求；\n- 【Edit Botpic】<==> `/setuserpic`：设置Bot的头像；\n- 【Edit Commands】<==> `/setcommands`：设置Bot支持的命令列表；（命令 + 说明）\n- 【Edit inline placeholder】<==> `/setinline`：设置Bot内联查询的提示词；\n- 【Edit Privacy Policy】：设置隐私条款，未设置时默认为使用官方的隐私条款；\n\n以上就是Bot的基本设置！\n\n\n\n另外，列一些个人觉得比较重要的命令：\n\n```\n/token:  获取HTTP API token\n/revoke: 吊销HTTP API token\n/cancel: 取消当前正在进行的操作\n/deletebot: 删除机器人\n```\n\n\n\n# 0x04：最后\n\n本篇文章的操作捏出了Bot的**形**，但是还不能进行真正的处理。虽然定义了命令列表，但此时发送命令，Bot是没有任何反应的。后面我们还需要给Bot编写程序，注入灵魂，让它动起来。\n\n\n\n","tags":["TON"],"categories":["blockchain"]},{"title":"广州到深圳之莽夫骑行","url":"/2024/08/06/hello-world/","content":"\n\n# 待更新...\n","tags":["骑行"],"categories":["life"]},{"title":"Android逆向：修改APK并重打包签名","url":"/2024/08/06/修改APK并重打包签名/","content":"\n在Android逆向中，经常需要对APK修改，然后重新打包并签名。这篇文章中，介绍了如何使用各个工具来完成这个过程。\n\n各个步骤以及所需工具：\n\n1. 解压APK文件； 工具：apktool\n2. 进行修改； 工具：看修改需求\n3. 重新打包APK； 工具：apktool\n4. 将APK对齐； 工具：zipalign\n5. 生成密钥文件，并对APK进行签名；工具：keytool、jarsigner\n\n\n\n小白鼠：demo.apk\n\n#### 目标：\n\n将`addThreeNum(1, 2, 3)`改为`addThreeNum(4, 5, 6)`，并且修改后能够成功运行。\n\n![image-20240806103111215](\\images\\修改APK并重打包签名\\image-20240806103111215.png)\n\n\n\n> demo.apk下载：https://www.123pan.com/s/9j4Xjv-MMAhv.html?提取码:tgno\n>\n> 用到的工具可自行从网上获取。\n\n\n\n#### 步骤1：解压APK\n\n使用apktool解压APK到output目录下\n\n```powershell\nE:\\> apktool d .\\demo.apk -o output\\\nI: Using Apktool 2.7.0 on demo.apk\nI: Loading resource table...\nI: Decoding AndroidManifest.xml with resources...\nI: Loading resource table from file: C:\\Users\\aaaka\\AppData\\Local\\apktool\\framework\\1.apk\nI: Regular manifest package...\nI: Decoding file-resources...\nI: Decoding values */* XMLs...\nI: Baksmaling classes.dex...\nI: Copying assets and libs...\nI: Copying unknown files...\nI: Copying original files...\nI: Copying META-INF/services directory\n```\n\n\n\n#### 步骤2：修改\n\n在output\\smali\\com\\example\\myapplication\\MainActivity.smail中，把`1 2 3 `改为` 4 5 6`\n\n![image-20240806095045017](\\images\\修改APK并重打包签名\\image-20240806095045017.png)\n\n\n\n#### 步骤3：重打包\n\n解压的逆过程，将output目录打包为newdemo.apk\n\n```powershell\nE:\\> apktool b output\\ -o .\\newdemo.apk\nI: Using Apktool 2.7.0\nI: Checking whether sources has changed...\nI: Smaling smali folder into classes.dex...\nI: Checking whether resources has changed...\nI: Building resources...\nI: Copying libs... (/lib)\nI: Copying libs... (/kotlin)\nI: Copying libs... (/META-INF/services)\nI: Building apk file...\nI: Copying unknown files/dir...\nI: Built apk into: .\\newdemo.apk\n```\n\n\n\n#### 步骤4：APK对齐\n\n（注意：当用到NDK开发，含有.so库时，需要添加`-p`参数）\n\n```powershell\nE:\\> zipalign -p -v 4 .\\newdemo.apk .\\newdemo-aligned.apk\nVerifying alignment of .\\newdemo-aligned.apk (4)...\n      49 AndroidManifest.xml (OK - compressed)\n    1688 classes.dex (OK - compressed)\n 3296246 kotlin/annotation/annotation.kotlin_builtins (OK - compressed)\n 3296897 kotlin/collections/collections.kotlin_builtins (OK - compressed)\n 3298508 kotlin/coroutines/coroutines.kotlin_builtins (OK - compressed)\n \t\t\t\t......(省略)......\n 3731560 resources.arsc (OK)\n 4709532 assets/dexopt/baseline.prof (OK)\n 4711368 assets/dexopt/baseline.profm (OK)\n 4711611 DebugProbesKt.bin (OK - compressed)\nVerification succesful\n```\n\n\n\n#### 步骤5：生成`.jks`密钥文件\n\n各个参数的含义可自行了解\n\n```powershell\nE:\\> keytool -genkeypair -v -keystore key.jks -keyalg RSA -keysize 2048 -validity 10000 -alias akakey\n输入密钥库口令:\n再次输入新口令:\n您的名字与姓氏是什么?\n  [Unknown]:  aka\n您的组织单位名称是什么?\n  [Unknown]:  Reverse\n您的组织名称是什么?\n  [Unknown]:  Android\n您所在的城市或区域名称是什么?\n  [Unknown]:  shenzhen\n您所在的省/市/自治区名称是什么?\n  [Unknown]:  guangdong\n该单位的双字母国家/地区代码是什么?\n  [Unknown]:  CN\nCN=aka, OU=Reverse, O=Android, L=shenzhen, ST=guangdong, C=CN是否正确?\n  [否]:  是\n\n正在为以下对象生成 2,048 位RSA密钥对和自签名证书 (SHA256withRSA) (有效期为 10,000 天):\n         CN=aka, OU=Reverse, O=Android, L=shenzhen, ST=guangdong, C=CN\n[正在存储key.jks]\n```\n\n\n\n#### 步骤6：重签名\n\n```powershell\nE:\\> apksigner sign --ks key.jks --ks-key-alias akakey --out .\\newdemo-aligned-signed.apk .\\newdemo-aligned.apk\nKeystore password for signer #1:\nE:\\>\n```\n\n\n\n#### 最后：尝试运行\n\n可以成功运行，并且修改有效。\n\n![image-20240806102009372](\\images\\修改APK并重打包签名\\image-20240806102009372.png)\n\n\n\n#### 思考：\n\n既然APK可以二次签名，并且能够成功运行。那么，APK中签名机制所起到的作用是什么呢？就是资源文件中META-INF目录下的`.RSA .SF .MF`三个文件。\n\n![image-20240806120006871](\\images\\修改APK并重打包签名\\image-20240806120006871.png)","tags":["Android","逆向"],"categories":["security"]}]